<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · ClusteredLowRankSolver.jl Documentation</title><meta name="title" content="Tutorial · ClusteredLowRankSolver.jl Documentation"/><meta property="og:title" content="Tutorial · ClusteredLowRankSolver.jl Documentation"/><meta property="twitter:title" content="Tutorial · ClusteredLowRankSolver.jl Documentation"/><meta name="description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="og:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="twitter:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClusteredLowRankSolver.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Running-example"><span>Running example</span></a></li><li><a class="tocitem" href="#Defining-the-objective"><span>Defining the objective</span></a></li><li><a class="tocitem" href="#Defining-the-constraints"><span>Defining the constraints</span></a></li><li><a class="tocitem" href="#Defining-the-problem"><span>Defining the problem</span></a></li><li><a class="tocitem" href="#Checking-for-obvious-mistakes"><span>Checking for obvious mistakes</span></a></li><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Retrieving-variables-from-the-solution"><span>Retrieving variables from the solution</span></a></li><li><a class="tocitem" href="#Running-the-example"><span>Running the example</span></a></li><li><a class="tocitem" href="#Rounding-the-solution"><span>Rounding the solution</span></a></li></ul></li><li><a class="tocitem" href="../advancedmodeling/">Advanced modeling</a></li><li><a class="tocitem" href="../solving/">Solving</a></li><li><a class="tocitem" href="../rounding/">Rounding</a></li><li><a class="tocitem" href="../sdpa/">SDPA-sparse format</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/delsarte/">Delsarte LP bound</a></li><li><a class="tocitem" href="../examples/sphere_packing/">Sphere packing</a></li><li><a class="tocitem" href="../examples/poly_opt/">Symmetric polynomial optimization</a></li><li><a class="tocitem" href="../examples/clustering/">Clustering</a></li><li><a class="tocitem" href="../examples/rounding/">Rounding the Delsarte LP bound</a></li></ul></li><li><a class="tocitem" href="../api/">API reference</a></li><li><a class="tocitem" href="../references/">References and citing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nanleij/ClusteredLowRankSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In this tutorial you will learn</p><ul><li>to build a <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a>, which includes<ul><li>creating the objective</li><li>creating a constraint</li><li>combining them into a <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a></li></ul></li><li>to solve a <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a></li><li>to find an exact optimal solution</li></ul><p>For explanation on more intricate parts of the interface, see <a href="../advancedmodeling/#Advanced-modeling">Advanced modeling</a>; for additional examples see the Examples section.</p><h2 id="Running-example"><a class="docs-heading-anchor" href="#Running-example">Running example</a><a id="Running-example-1"></a><a class="docs-heading-anchor-permalink" href="#Running-example" title="Permalink"></a></h2><p>We will explain the interface using an example from polynomial optimization. Suppose we want to find the global minimum (or a lower bound on this) of the polynomial</p><p class="math-container">\[f(u,v,t,w) = -ut^3+4vt^2w + 4 utw^2 + 2vw^3 + 4  ut+ 4t^2 -10 vw - 10  w^2 +2\]</p><p>in the domain <span>$[-1/2, 1/2]^4$</span>.  We can relax the problem using a sum-of-squares characterization:</p><p class="math-container">\[\begin{aligned}
    \text{maximize} \quad &amp; M &amp; \\
    \text{subject to} \quad &amp; f-M &amp; = s_0 + \sum_i w_i s_i. \\
\end{aligned}\]</p><p>where the <span>$w_i$</span> are polynomial weights describing the domain and <span>$s_i$</span> are sum-of-squares polynomials. In this example we use</p><p class="math-container">\[\begin{aligned}
    [-1/2, 1/2]^4 = \{(u,v,t,w): p(u), p(v), p(t), p(w) \geq 0\}
\end{aligned}\]</p><p>with <span>$p(x) = 1/4 - x^2$</span>. Given a vector <span>$m$</span> whose entries form a basis of the space of polynomials up to degree <span>$d$</span>, we can parametrize a sum-of-squares polynomial <span>$s$</span> of degree <span>$2d$</span> by a positive semidefinite matrix <span>$Y$</span> with</p><p class="math-container">\[    s = ⟨ Y, mm^{\sf T} ⟩.\]</p><p>The problem parameters are now </p><ul><li>the polynomial <span>$f$</span></li><li>the weight polynomials <span>$w_i$</span></li><li>the degree of the relaxation <span>$d$</span></li></ul><p>We will start with building a function that takes these parameters, and constructs the <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a>. Since the user will give the polynomial <code>f</code> and the weights, we need to extract the polynomial ring and the polynomial variables.</p><pre><code class="language-julia hljs">using ClusteredLowRankSolver, Nemo
function min_f(f, ws, d; basis_change=true)
    # extract the polynomial ring
    R = parent(f)
    x = gens(R)
    n = nvars(R)</code></pre><h2 id="Defining-the-objective"><a class="docs-heading-anchor" href="#Defining-the-objective">Defining the objective</a><a id="Defining-the-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-objective" title="Permalink"></a></h2><p>First we will define the <a href="#ClusteredLowRankSolver.Objective"><code>Objective</code></a>. This consists of a constant offset, a dictionary with the coefficient matrices for the positive semidefinite matrix variables appearing in the objective, and a dictionary with the scalar coefficients for the free variables used in the objective. In this example, </p><ul><li>the constant offset is <code>0</code>, </li><li>the dictionary of matrix coefficients is empty because we do not use the matrix variables in the objective,</li><li>and the dictionary of scalar coefficients has one entry corresponding to <span>$M$</span> </li></ul><p>This gives the first part of our function:</p><pre><code class="language-julia hljs">    # Define the objective
    obj = Objective(0, Dict(), Dict(:M =&gt; 1))</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Objective" href="#ClusteredLowRankSolver.Objective"><code>ClusteredLowRankSolver.Objective</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Objective(constant, matrixcoeff::Dict, freecoeff::Dict)</code></pre><p>The objective for the Problem.</p><p>Arguments:</p><ul><li><code>constant</code>: A constant offset of the objective value.</li><li><code>matrixcoeff</code>: A <code>Dict</code> with positive semidefinite matrix variable names as keys and the objective matrices as values.</li><li><code>freecoeff</code>: A <code>Dict</code> with free variable names as keys and the coefficients as values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L507-L516">source</a></section></article><h2 id="Defining-the-constraints"><a class="docs-heading-anchor" href="#Defining-the-constraints">Defining the constraints</a><a id="Defining-the-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-constraints" title="Permalink"></a></h2><p>Now we will define the constraints. In <code>ClusteredLowRankSolver</code> a <code>Constraint</code> is of the form</p><p class="math-container">\[    \sum_i \langle A_i, Y_i \rangle + \sum_j b_j y_j = c. \]</p><p>To define it, we need the right-hand side <span>$c$</span>, the matrix coefficients <span>$A_i$</span> for the positive semidefinite matrix variables, and the coefficients <span>$b_j$</span> for the free variables. Here the scalars <span>$c$</span> and <span>$b_j$</span> and the entries of <span>$A_i$</span> can either be constants or polynomials. When these are polynomials, we also need a unisolvent set of samples. In this example, </p><ul><li>the right-hand side <span>$c$</span> is the polynomial <span>$f$</span>, </li><li>the matrix coefficients <span>$A_i$</span> are the weight polynomials times a suitable low rank matrix of the form <span>$mm^{\sf T}$</span>, </li><li>and we have one free variable <span>$M$</span>, with coefficient <span>$1$</span>.</li></ul><h4 id="Defining-the-polynomial-basis-and-the-samples"><a class="docs-heading-anchor" href="#Defining-the-polynomial-basis-and-the-samples">Defining the polynomial basis and the samples</a><a id="Defining-the-polynomial-basis-and-the-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-polynomial-basis-and-the-samples" title="Permalink"></a></h4><p>We will first define the vector <span>$m$</span> of basis polynomials, and the samples. For simplicity we will use the monomial basis, and the samples defined by the rational points in the simplex with denominator <span>$2d$</span>. </p><pre><code class="language-julia hljs">    basis = basis_monomial(2d, x...)
    samples = sample_points_simplex(n, 2d; T=Rational{BigInt})</code></pre><p>See <a href="../advancedmodeling/#Sampling">Sampling</a> for more explanation on sampling and unisolvence. In more complicated situations, we can improve the basis with <a href="#ClusteredLowRankSolver.approximatefekete"><code>approximatefekete</code></a>. This orthogonalizes the basis with respect to the sample points, and if <code>samples</code> contains more samples than needed, this selects a good subset of the samples. We include this in the function using a keyword argument <code>basis_change=true</code> and</p><pre><code class="language-julia hljs">    if basis_change
        basis, samples = approximatefekete(basis, samples)
    end</code></pre><p>This returns a basis of <code>SampledMPolyRingElem</code>&#39;s, which we can only evaluate at samples from <code>samples</code>. Common operations such as multiplications and additions work with these sampled polynomials, but operations such as extracting the degree is not possible since that requires expressing the polynomials in a graded basis. However, if the initial <code>basis</code> is ordered on degree, the final <code>basis</code> will have the same ordering, so we store the degrees using the code</p><pre><code class="language-julia hljs">    degrees = total_degree.(basis_monomial(2d, x...))</code></pre><h4 id="Defining-the-coefficients-for-the-constraint"><a class="docs-heading-anchor" href="#Defining-the-coefficients-for-the-constraint">Defining the coefficients for the constraint</a><a id="Defining-the-coefficients-for-the-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-coefficients-for-the-constraint" title="Permalink"></a></h4><p>Now we are ready to define the low-rank matrix coefficients for the sum of squares polynomials.  For each weight polynomial, we need to add the matrix coefficient corresponding to that weight to the dictionary of matrix coefficients. Since we want polynomials of degree <code>2d</code>, we first need to select the part of the basis that we use in the sum-of-squares polynomials.</p><pre><code class="language-julia hljs">    psd_dict = Dict()
    for (i, w) in enumerate(ws)
        basispart = [basis[j] for j in eachindex(basis) if 2degrees[j] + total_degree(w) &lt;= 2d]
        psd_dict[(:sos, i)] = LowRankMatPol([w], [basispart])
    end</code></pre><p>The size of the matrices is implicitely given by the size of the <a href="#ClusteredLowRankSolver.LowRankMatPol"><code>LowRankMatPol</code></a>, which is defined by the prefactors and the rank one terms.</p><p>Similarly, we can create the dictionary with the free variables using </p><pre><code class="language-julia hljs">    free_dict = Dict(:M =&gt; 1)</code></pre><h4 id="Defining-the-constraint"><a class="docs-heading-anchor" href="#Defining-the-constraint">Defining the constraint</a><a id="Defining-the-constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-constraint" title="Permalink"></a></h4><p>Now we can construct the <a href="#ClusteredLowRankSolver.Constraint"><code>Constraint</code></a> with</p><pre><code class="language-julia hljs">    con = Constraint(f, psd_dict, free_dict, samples)</code></pre><p>From the constraint, the dictionaries and coefficients can be retrieved using <a href="#ClusteredLowRankSolver.matrixcoeff"><code>matrixcoeff</code></a>(s) and <a href="#ClusteredLowRankSolver.freecoeff"><code>freecoeff</code></a>s.</p><p>Specifying non-polynomial constraints works similarly, in which case no samples should be supplied to the <a href="#ClusteredLowRankSolver.Constraint"><code>Constraint</code></a> struct.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Constraint" href="#ClusteredLowRankSolver.Constraint"><code>ClusteredLowRankSolver.Constraint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Constraint(constant, matrixcoeff, freecoeff[, samples, scalings])</code></pre><p>Models a polynomial constaint of the form</p><p class="math-container">\[    ∑_i ⟨ A_i(x), Y_i  ⟩ + ∑_j b_j(x) y_j = c(x)\]</p><p>using sampling on <code>samples</code>. Here the samples are only required if <span>$A_i$</span>, <span>$b_j$</span>, and <span>$c$</span> are polynomials. When the coefficient matrix <span>$A_i$</span> has block structure with equal sized blocks, the <code>Block</code> struct can be used as key to indicate to which subblock the given matrix corresponds.</p><p>Arguments:</p><ul><li><code>constant</code>: The right hand side <span>$c(x)$</span></li><li><code>matrixcoeff::Dict</code>: The coefficient matrices for the positive semidefinite matrix variables.</li><li><code>freecoeff::Dict</code>: The coefficients for the free variables.</li><li><code>samples::Vector</code>: The sample set on which the constraint should be satisfied. Required for polynomial constraints.</li><li><code>scalings::Vector</code>: Optional; scale the constraint with a factor depending on the sample index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L477-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.LowRankMatPol" href="#ClusteredLowRankSolver.LowRankMatPol"><code>ClusteredLowRankSolver.LowRankMatPol</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LowRankMatPol(lambda::Vector, vs::Vector{Vector}[, ws::Vector{Vector}])</code></pre><p>The matrix <span>$∑_i λ_i v_i w_i^{\sf T}$</span> where <span>$v_i$</span> are the entries of <code>vs</code> and <span>$w_i$</span> the entries of <code>ws</code></p><p>If <code>ws</code> is not specified, use <code>ws = vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L273-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.approximatefekete" href="#ClusteredLowRankSolver.approximatefekete"><code>ClusteredLowRankSolver.approximatefekete</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">approximatefekete(basis, samples; base_ring=BigFloat) -&gt; basis, samples</code></pre><p>Compute approximate fekete points based on samples and a corresponding orthogonal basis. The basis consists of sampled polynomials, sampled at <code>samples</code>.</p><p>This preserves a degree ordering of <code>basis</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixcoeff" href="#ClusteredLowRankSolver.matrixcoeff"><code>ClusteredLowRankSolver.matrixcoeff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrixcoeff(x::Union{Constraint, Objective}, name)</code></pre><p>Return the matrix coefficient corresponding to <code>name</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L523-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixcoeffs" href="#ClusteredLowRankSolver.matrixcoeffs"><code>ClusteredLowRankSolver.matrixcoeffs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrixcoeffs(x::Union{Constraint, Objective})</code></pre><p>Return the dictionary of matrix coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L531-L535">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freecoeff" href="#ClusteredLowRankSolver.freecoeff"><code>ClusteredLowRankSolver.freecoeff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freecoeff(x::Union{Constraint, Objective}, name)</code></pre><p>Return the coefficient of the free variable corresponding to <code>name</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L547-L551">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freecoeffs" href="#ClusteredLowRankSolver.freecoeffs"><code>ClusteredLowRankSolver.freecoeffs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freecoeffs(x::Union{Constraint, Objective})</code></pre><p>Return the dictionary of coefficients for the free variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L539-L543">source</a></section></article><h2 id="Defining-the-problem"><a class="docs-heading-anchor" href="#Defining-the-problem">Defining the problem</a><a id="Defining-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-problem" title="Permalink"></a></h2><p>Now that we have the objective and the constraint, we can create the <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a> with</p><pre><code class="language-julia hljs">    problem = Problem(Maximize(obj), [con])</code></pre><p>Here the first argument gives the objective and the optimization sense (maximization or minimization). The second argument is a vector of the constraints defining the feasible region (in this example, only the constraint <code>con</code>). The objective and constraints can be retrieved from the problem using <a href="#ClusteredLowRankSolver.objective"><code>objective</code></a> and <a href="#ClusteredLowRankSolver.constraints"><code>constraints</code></a>. Instead of first constructing all constraints and then defining the <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a>, it is also possible to first define the problem using the objective, and then add the constraints with the function <a href="#ClusteredLowRankSolver.addconstraint!"><code>addconstraint!</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Problem" href="#ClusteredLowRankSolver.Problem"><code>ClusteredLowRankSolver.Problem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    Problem(maximize::Bool, objective::Objective, constraints::Vector{Constraint})</code></pre><pre><code class="nohighlight hljs">    Problem(obj::Union{Maximize, Minimize}, constraints::Vector)</code></pre><p>Combine the objective and constraints into a low-rank polynomial problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L573-L581">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Maximize" href="#ClusteredLowRankSolver.Maximize"><code>ClusteredLowRankSolver.Maximize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Maximize(obj)</code></pre><p>Maximize the objective</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L556-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Minimize" href="#ClusteredLowRankSolver.Minimize"><code>ClusteredLowRankSolver.Minimize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Minimize(obj)</code></pre><p>Minimize the objective</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L564-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.objective" href="#ClusteredLowRankSolver.objective"><code>ClusteredLowRankSolver.objective</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objective(x::Union{Maximize, Minimize, Problem})</code></pre><p>Return the objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L606-L610">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.constraints" href="#ClusteredLowRankSolver.constraints"><code>ClusteredLowRankSolver.constraints</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">constraints(problem::Problem)</code></pre><p>Return the constraints of <code>problem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L599-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.addconstraint!" href="#ClusteredLowRankSolver.addconstraint!"><code>ClusteredLowRankSolver.addconstraint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addconstraint!(problem, constraint)</code></pre><p>Add <code>constraint</code> to the constraints of <code>problem</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L629-L633">source</a></section></article><h2 id="Checking-for-obvious-mistakes"><a class="docs-heading-anchor" href="#Checking-for-obvious-mistakes">Checking for obvious mistakes</a><a id="Checking-for-obvious-mistakes-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-for-obvious-mistakes" title="Permalink"></a></h2><p>Some basic checks on the problem and/or semidefinite program can be done using <a href="#ClusteredLowRankSolver.check_problem"><code>check_problem</code></a> and <a href="#ClusteredLowRankSolver.check_sdp!"><code>check_sdp!</code></a>. The <a href="#ClusteredLowRankSolver.check_problem"><code>check_problem</code></a> function checks that</p><ul><li>the sizes of the vectors in the low-rank constraint matrices are the same,</li><li>all constraints use at least one positive semidefinite matrix variable,</li><li>all variables in the objective are actually used in the constraints.</li></ul><p>The <a href="#ClusteredLowRankSolver.check_sdp!"><code>check_sdp!</code></a> function </p><ul><li>checks that the constraint matrices are symmetric,</li><li>removes empty matrices and zero matrices.</li></ul><pre><code class="language-julia hljs">    @assert check_problem(problem)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.check_problem" href="#ClusteredLowRankSolver.check_problem"><code>ClusteredLowRankSolver.check_problem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_problem(problem::LowRankPolProblem)</code></pre><p>Check for obvious mistakes in the constraints and objective</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/checks.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.check_sdp!" href="#ClusteredLowRankSolver.check_sdp!"><code>ClusteredLowRankSolver.check_sdp!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_sdp!(sdp::ClusteredLowRankSDP)</code></pre><p>Check whether the constraint matrices are symmetric, and remove empty constraint matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/checks.jl#L115-L119">source</a></section></article><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><p>We can solve the <a href="#ClusteredLowRankSolver.Problem"><code>Problem</code></a> with the function <a href="../solving/#ClusteredLowRankSolver.solvesdp"><code>solvesdp</code></a>:</p><pre><code class="language-julia hljs">    status, primalsol, dualsol, time, errorcode = solvesdp(problem; prec=512, duality_gap_threshold=1e-60)</code></pre><p>This function has multiple options including for example the number of bits used for solving the semidefinite program (<code>prec</code>) and how close the solution should be to optimality (<code>duality_gap_threshold</code>); see the page about the <a href="../solving/#solver">solver</a> for more information.</p><p>Alternatively, it is possible to explicitely convert the problem into a semidefinite program using</p><pre><code class="language-julia hljs">    sdp = ClusteredLowRankSDP(problem)</code></pre><p>which can also be solved with</p><pre><code class="language-julia hljs">    status, sol, time, errorcode = solvesdp(sdp)</code></pre><p>This is for example useful when you wish to save the semidefinite program (e.g., using <code>Serialization</code>), or when you want to perform the extra checks provided by <a href="#ClusteredLowRankSolver.check_sdp!"><code>check_sdp!</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.solvesdp-tutorial" href="#ClusteredLowRankSolver.solvesdp-tutorial"><code>ClusteredLowRankSolver.solvesdp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">	solvesdp(problem::Problem; kwargs...)</code></pre><pre><code class="nohighlight hljs">    solvesdp(sdp::ClusteredLowRankSDP; kwargs...)</code></pre><p>Solve the semidefinite program generated from <code>problem</code> or <code>sdp</code>. </p><p>Keyword arguments:</p><ul><li><code>prec</code> (default: <code>precision(BigFloat)</code>): the precision used</li><li><code>gamma</code> (default: <code>0.9</code>): the step length reduction; a maximum step length of α reduces to a step length of <code>max(gamma*α,1)</code></li><li><code>beta_(in)feasible</code> (default: <code>0.1</code> (<code>0.3</code>)): the amount mu is tried to be reduced by in each iteration, for (in)feasible solutions</li><li><code>omega_p/d</code> (default: <code>10^10</code>): the starting matrix variable for the primal/dual is <code>omega_p/d*I</code></li><li><code>maxiterations</code> (default: <code>500</code>): the maximum number of iterations</li><li><code>duality_gap_threshold</code> (default: <code>10^-15</code>): how near to optimal the solution needs to be</li><li><code>primal/dual_error_threshold</code> (default:<code>10^-30</code>): how feasible the primal/dual solution needs to be</li><li><code>max_complementary_gap</code> (default: <code>10^100</code>): the maximum of <code>dot(X,Y)/nrows(X)</code> allowed</li><li><code>need_primal_feasible/need_dual_feasible</code> (default: <code>false</code>): terminate when the solution is primal/dual feasible</li><li><code>verbose</code> (default: <code>true</code>): print information after every iteration if true</li><li><code>step_length_threshold</code> (default: <code>10^-7</code>): the minimum step length allowed</li><li><code>primalsol</code> (default: <code>nothing</code>): start from the solution <code>(primalsol, dualsol)</code> if both <code>primalsol</code> and <code>dualsol</code> are given</li><li><code>dualsol</code> (default: <code>nothing</code>): start from the solution <code>(primalsol, dualsol)</code> if both <code>primalsol</code> and <code>dualsol</code> are given</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/solver.jl#L13-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.ClusteredLowRankSDP" href="#ClusteredLowRankSolver.ClusteredLowRankSDP"><code>ClusteredLowRankSolver.ClusteredLowRankSDP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ClusteredLowRankSDP(problem::Problem; prec=precision(BigFloat), verbose=false)</code></pre><p>Define a <code>ClusteredLowRankSDP</code> based on <code>problem</code>.</p><p>Keyword arguments:</p><ul><li><code>prec</code> (default: <code>precision(BigFloat)</code>): the precision of the result</li><li><code>verbose</code> (default: false): print progress to the standard output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L819-L827">source</a></section></article><h2 id="Retrieving-variables-from-the-solution"><a class="docs-heading-anchor" href="#Retrieving-variables-from-the-solution">Retrieving variables from the solution</a><a id="Retrieving-variables-from-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Retrieving-variables-from-the-solution" title="Permalink"></a></h2><p>The solver returns, among others, the primal and dual solutions as <code>PrimalSolution{BigFloat}</code> and <code>DualSolution{BigFloat}</code>. To retrieve the variables, it is possible to use</p><pre><code class="language-julia hljs">    matrixvar(dualsol, (:sos, 1))</code></pre><p>and <code>freevar(dualsol, :M)</code> for free variables. Similarly, use <a href="#ClusteredLowRankSolver.matrixvars"><code>matrixvars</code></a> and <a href="#ClusteredLowRankSolver.freevars"><code>freevars</code></a> to iterate over all variables:</p><pre><code class="language-julia hljs">    for (k, m) in matrixvars(dualsol)
        # do stuff with the matrix m or the name k
    end </code></pre><p>To compute the objective for this solution, we can use</p><pre><code class="language-julia hljs">    objective = objvalue(problem, dualsol)</code></pre><p>We might also want to return the problem and the solutions:</p><pre><code class="language-julia hljs">    return objective, problem, primalsol, dualsol
end</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.PrimalSolution" href="#ClusteredLowRankSolver.PrimalSolution"><code>ClusteredLowRankSolver.PrimalSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrimalSolution{T}</code></pre><p>A primal solution to the semidefinite program, with fields</p><ul><li><code>base_ring</code></li><li><code>x::Vector{T}</code></li><li><code>matrixvars::Dict{Any, Matrix{T}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1086-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.DualSolution" href="#ClusteredLowRankSolver.DualSolution"><code>ClusteredLowRankSolver.DualSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DualSolution{T}</code></pre><p>A dual solution to the semidefinite program, with fields</p><ul><li><code>base_ring</code></li><li><code>matrixvars::Dict{Any, Matrix{T}}</code></li><li><code>freevars::Dict{Any, T}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1100-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixvar" href="#ClusteredLowRankSolver.matrixvar"><code>ClusteredLowRankSolver.matrixvar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrixvar(sol, name)</code></pre><p>Return the matrix variable corresponding to name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1157-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixvars" href="#ClusteredLowRankSolver.matrixvars"><code>ClusteredLowRankSolver.matrixvars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrixvars(sol)</code></pre><p>Return the dictionary of matrix variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1170-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freevar" href="#ClusteredLowRankSolver.freevar"><code>ClusteredLowRankSolver.freevar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freevar(sol, name)</code></pre><p>Return the free variable corresponding to name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1183-L1187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freevars" href="#ClusteredLowRankSolver.freevars"><code>ClusteredLowRankSolver.freevars</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">freevars(sol)</code></pre><p>Return the dictionary of the free variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1191-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.objvalue" href="#ClusteredLowRankSolver.objvalue"><code>ClusteredLowRankSolver.objvalue</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objvalue(objective::Objective, sol::DualSolution)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1114-L1116">source</a></section><section><div><pre><code class="language-julia hljs">objvalue(problem::Problem, sol::DualSolution)</code></pre><p>Return the objective value of the dual solution with respect to the given objective or problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1138-L1142">source</a></section></article><h2 id="Running-the-example"><a class="docs-heading-anchor" href="#Running-the-example">Running the example</a><a id="Running-the-example-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-example" title="Permalink"></a></h2><p>Now we can define the problem parameters and run the function</p><pre><code class="language-julia hljs">d = 2
R, (u,v,t,w) = polynomial_ring(QQ, 4)
f = -u*t^3 + 4v*t^2*w + 4u*t*w^2 + 2v*w^3 + 4u*t+ 4t^2 - 10v*w - 10w^2 +2
# the function for the weights
p(x) = 1//4 - x^2
ws = [R(1), p(u), p(v), p(t), p(w)]
# call the function
obj, problem, primalsol, dualsol = min_f(f, ws, d)
obj</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-3.180096625844998335319568973990471892050902347714187740434770044682071344337001</code></pre><h2 id="Rounding-the-solution"><a class="docs-heading-anchor" href="#Rounding-the-solution">Rounding the solution</a><a id="Rounding-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding-the-solution" title="Permalink"></a></h2><p>Here we explain how we can heuristically extract an exact optimal solution from the numerical solution. This approach has been developed in the paper [<a href="../references/#CLL24">1</a>], and we refer to this paper for more information on the assumptions and the method. See <a href="../rounding/#secrounding">Rounding</a> for more information on how to use the rounding implementation. </p><p>Since we expect the solution to be relatively nice in terms of polynomials, we avoid doing the basis change generated by <code>approximatefekete</code>, and try to find the field using the following code. </p><pre><code class="language-julia hljs">obj, problem, primalsol, dualsol = min_f(f, ws, 2; basis_change=false)
N, gapprox = find_field(primalsol, dualsol)
N</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number field with defining polynomial -3*x^2 + 40*x + 20
  over rational field</code></pre><p>We find a field of degree 2. Trying to round the objective to this field gives</p><pre><code class="language-julia hljs">to_field(obj, N, gapprox)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">115//18*z - 7//72</code></pre><p>Since this is a small expression, this gives some indication that <code>N</code> is the correct field. Now we will try to round the numerical solution to this field. First we convert the problem to the field <code>N</code>. This can be done using the function <a href="#ClusteredLowRankSolver.generic_embedding"><code>generic_embedding</code></a>. </p><pre><code class="language-julia hljs">problem = map(x-&gt;generic_embedding(x, gen(N), base_ring=N), problem)</code></pre><p>In general it is advisable to use coefficient matching to define the semidefinite program for the rounding procedure. For this we need to build a monomial basis for each constraint. </p><pre><code class="language-julia hljs">R, x = polynomial_ring(N, 4)
monbasis = basis_monomial(4, x...)</code></pre><p>Then we are ready to try the rounding procedure. This will not always succeed without tuning the settings, but in this example it does. See the <a href="../rounding/#secrounding">Rounding</a> page for information on the settings.</p><pre><code class="language-julia hljs">success, exactdualsol = exact_solution(problem, primalsol, dualsol;
        FF=N, g=gapprox, monomial_bases=[monbasis])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">** Starting computation of basis transformations **
  Block (:sos, 2) of size 5 x 5
  Block (:sos, 3) of size 5 x 5
  Block (:sos, 5) of size 5 x 5
  Block (:sos, 4) of size 5 x 5
    Block (:sos, 4) has 3 kernel vectors. The maximum numerator and denominator are 1 and 1
    After reduction, the maximum number of the basis transformation matrix is 20
  Block (:sos, 1) of size 15 x 15
    Block (:sos, 1) has 4 kernel vectors. The maximum numerator and denominator are 10 and 4
    After reduction, the maximum number of the basis transformation matrix is 1245
** Finished computation of basis transformations (1.7650185s) **
** Transforming the problem and the solution ** (0.422212053s)
** Projection the solution into the affine space **
  Reducing the system from 115 columns to 115 columns
  Constructing the linear system... (0.18933753s)
  Computing an approximate solution in the extension field... (0.101369363s)
  Preprocessing to get an integer system... (0.004395701s)
  Finding the pivots of A using RREF mod p... (0.014508197 0.005498907 s)
  We did not find enough pivots (126 instead of 140)
  Solving the system of size 126 x 147 using the pseudoinverse... 0.013790462s
** Finished projection into affine space (0.619859884s) **
** Checking feasibility **
The slacks are satisfied (checked or ensured by solving the system)
Checking sdp constraints
 done (0.045550393)</code></pre><p>If <code>success</code> is <code>true</code>, the solution <code>exactdualsol</code> is guaranteed to be feasible. The affine constraints have been checked in exact arithmetic, and positive semidefiniteness has been checked in ball arithmetic.   We can check that we get the same objective as directly rounding the objective to the field <code>N</code>.</p><pre><code class="language-julia hljs">objvalue(problem, exactdualsol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">115//18*z - 7//72</code></pre><p>The output of the rounding procedure to the terminal contains some information about the number of kernel vectors and the largest numbers in absolute value occuring in those kernel vectors, some progress messages, and some messages about the system that is solved.  </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.find_field-tutorial" href="#ClusteredLowRankSolver.find_field-tutorial"><code>ClusteredLowRankSolver.find_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_field(primalsol, dualsol, max_degree=4; valbound=1e-15, errbound=1e-15, bits=100, max_coeff=1000)</code></pre><p>Heuristically find a field over which the kernel can probably be defined. </p><p>Only consider values at least <code>valbound</code> in absolute value. Find minimal polynomials  such that the chosen entries are approximately generators with an error bound of <code>errbound</code>. Use <code>bits</code> number of bits and reject minimal polynomials with a maximum coefficient of more than <code>max_coeff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/find_field.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.exact_solution-tutorial" href="#ClusteredLowRankSolver.exact_solution-tutorial"><code>ClusteredLowRankSolver.exact_solution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exact_solution(problem::Problem, primalsol::PrimalSolution, dualsol::DualSolution; transformed=false, FF = QQ, g=1, settings::RoundingSettings=RoundingSettings(), monomial_bases=nothing)</code></pre><p>Compute and return an exact solution to the problem, given a primal solution, dual solution and a field <code>FF</code> with approximate generator <code>g</code>. Return <code>(success, exactdualsol)</code> if <code>transformed=false</code>, and <code>(success, pd_transformed_exactsolution, transformations)</code> if <code>transformed=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/rounding.jl#L1336-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.generic_embedding" href="#ClusteredLowRankSolver.generic_embedding"><code>ClusteredLowRankSolver.generic_embedding</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generic_embedding(exactvalue, g; base_ring=BigFloat)</code></pre><p>Convert the exact numbers from a number field to floating point approximations,  using a floating point approximation of a generator g of the field.</p><p>Convert rationals and integers to the same numbers in base_ring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/interface.jl#L1600-L1607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.to_field" href="#ClusteredLowRankSolver.to_field"><code>ClusteredLowRankSolver.to_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_field(v, N, g; bits=100, errbound=1e-15)</code></pre><p>Find an approximation of v in the number field N, using the approximate generator g of N.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/1a03bd8088d1d1e3ffa1e6ada435317f2431964b/src/find_field.jl#L117-L121">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../advancedmodeling/">Advanced modeling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 17 December 2024 08:58">Tuesday 17 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
