<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · ClusteredLowRankSolver.jl Documentation</title><meta name="title" content="API reference · ClusteredLowRankSolver.jl Documentation"/><meta property="og:title" content="API reference · ClusteredLowRankSolver.jl Documentation"/><meta property="twitter:title" content="API reference · ClusteredLowRankSolver.jl Documentation"/><meta name="description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="og:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="twitter:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClusteredLowRankSolver.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../advancedmodeling/">Advanced modeling</a></li><li><a class="tocitem" href="../solving/">Solving</a></li><li><a class="tocitem" href="../rounding/">Rounding</a></li><li><a class="tocitem" href="../sdpa/">SDPA-sparse format</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/delsarte/">Delsarte LP bound</a></li><li><a class="tocitem" href="../examples/sphere_packing/">Sphere packing</a></li><li><a class="tocitem" href="../examples/poly_opt/">Symmetric polynomial optimization</a></li><li><a class="tocitem" href="../examples/clustering/">Clustering</a></li><li><a class="tocitem" href="../examples/rounding/">Rounding the Delsarte LP bound</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../references/">References and citing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/nanleij/ClusteredLowRankSolver.jl.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Block-api" href="#ClusteredLowRankSolver.Block-api"><code>ClusteredLowRankSolver.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Block(l::Any[, r::Int, s::Int])</code></pre><p>Specifies a block corresponding to the positive semidefinite variable <code>l</code>.</p><p>Specifying <code>r,s</code> makes the <code>Block</code> correspond to the <code>r,s</code> subblock of the variable <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.ClusteredLowRankSDP-Tuple{Problem}-api" href="#ClusteredLowRankSolver.ClusteredLowRankSDP-Tuple{Problem}-api"><code>ClusteredLowRankSolver.ClusteredLowRankSDP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ClusteredLowRankSDP(problem::Problem; prec=precision(BigFloat), verbose=false)</code></pre><p>Define a <code>ClusteredLowRankSDP</code> based on <code>problem</code>.</p><p>Keyword arguments:</p><ul><li><code>prec</code> (default: <code>precision(BigFloat)</code>): the precision of the result</li><li><code>verbose</code> (default: false): print progress to the standard output</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Constraint-api" href="#ClusteredLowRankSolver.Constraint-api"><code>ClusteredLowRankSolver.Constraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Constraint(constant, matrixcoeff, freecoeff[, samples, scalings])</code></pre><p>Models a polynomial constaint of the form</p><p class="math-container">\[    ∑_i ⟨ A_i(x), Y_i  ⟩ + ∑_j b_j(x) y_j = c(x)\]</p><p>using sampling on <code>samples</code>. Here the samples are only required if <span>$A_i$</span>, <span>$b_j$</span>, and <span>$c$</span> are polynomials. When the coefficient matrix <span>$A_i$</span> has block structure with equal sized blocks, the <code>Block</code> struct can be used as key to indicate to which subblock the given matrix corresponds.</p><p>Arguments:</p><ul><li><code>constant</code>: The right hand side <span>$c(x)$</span></li><li><code>matrixcoeff::Dict</code>: The coefficient matrices for the positive semidefinite matrix variables.</li><li><code>freecoeff::Dict</code>: The coefficients for the free variables.</li><li><code>samples::Vector</code>: The sample set on which the constraint should be satisfied. Required for polynomial constraints.</li><li><code>scalings::Vector</code>: Optional; scale the constraint with a factor depending on the sample index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.DualSolution-api" href="#ClusteredLowRankSolver.DualSolution-api"><code>ClusteredLowRankSolver.DualSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DualSolution{T}</code></pre><p>A dual solution to the semidefinite program, with fields</p><ul><li><code>base_ring</code></li><li><code>matrixvars::Dict{Any, Matrix{T}}</code></li><li><code>freevars::Dict{Any, T}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.LowRankMatPol-api" href="#ClusteredLowRankSolver.LowRankMatPol-api"><code>ClusteredLowRankSolver.LowRankMatPol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LowRankMatPol(lambda::Vector, vs::Vector{Vector}[, ws::Vector{Vector}])</code></pre><p>The matrix <span>$∑_i λ_i v_i w_i^{\sf T}$</span> where <span>$v_i$</span> are the entries of <code>vs</code> and <span>$w_i$</span> the entries of <code>ws</code></p><p>If <code>ws</code> is not specified, use <code>ws = vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Maximize-api" href="#ClusteredLowRankSolver.Maximize-api"><code>ClusteredLowRankSolver.Maximize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Maximize(obj)</code></pre><p>Maximize the objective</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Minimize-api" href="#ClusteredLowRankSolver.Minimize-api"><code>ClusteredLowRankSolver.Minimize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Minimize(obj)</code></pre><p>Minimize the objective</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Objective-api" href="#ClusteredLowRankSolver.Objective-api"><code>ClusteredLowRankSolver.Objective</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Objective(constant, matrixcoeff::Dict, freecoeff::Dict)</code></pre><p>The objective for the Problem.</p><p>Arguments:</p><ul><li><code>constant</code>: A constant offset of the objective value.</li><li><code>matrixcoeff</code>: A <code>Dict</code> with positive semidefinite matrix variable names as keys and the objective matrices as values.</li><li><code>freecoeff</code>: A <code>Dict</code> with free variable names as keys and the coefficients as values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.PrimalSolution-api" href="#ClusteredLowRankSolver.PrimalSolution-api"><code>ClusteredLowRankSolver.PrimalSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrimalSolution{T}</code></pre><p>A primal solution to the semidefinite program, with fields</p><ul><li><code>base_ring</code></li><li><code>x::Vector{T}</code></li><li><code>matrixvars::Dict{Any, Matrix{T}}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.Problem-api" href="#ClusteredLowRankSolver.Problem-api"><code>ClusteredLowRankSolver.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">    Problem(maximize::Bool, objective::Objective, constraints::Vector{Constraint})</code></pre><pre><code class="nohighlight hljs">    Problem(obj::Union{Maximize, Minimize}, constraints::Vector)</code></pre><p>Combine the objective and constraints into a low-rank polynomial problem.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.RoundingSettings-api" href="#ClusteredLowRankSolver.RoundingSettings-api"><code>ClusteredLowRankSolver.RoundingSettings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RoundingSettings(settings...)</code></pre><p>Settings for the rounding procedure:</p><ol><li>Finding the kernel<ul><li><code>kernel_errbound</code>: (default: <code>1e-10</code>) the allowed error for the kernel vectors. That is, the maximum entry of Xv is in absolute value at most this</li><li><code>kernel_round_errbound</code>: (default: <code>1e-15</code>) the maximum allowed error when rounding the reduced row-echelon form entrywise</li><li><code>kernel_use_primal</code>: (default: <code>true</code>) use the primal solution to find the kernel vectors  (otherwise, use an SVD of the dual solution)</li><li><code>kernel_lll</code>: (default: <code>false</code>) if true, use the LLL algorithm to find the nullspace of the kernel. Otherwise, use the reduced row-echelon form to find kernel vectors.</li><li><code>kernel_bits</code>: (default: <code>1000</code>) the maximum number of bits to be used in the LLL algorithm (for finding relations or finding the entries of the RREF)</li></ul></li><li>Reducing the kernel vectors<ul><li><code>reduce_kernelvectors</code>: (default: <code>true</code>) apply the reduction step or not</li><li><code>reduce_kernelvectors_cutoff</code>: (default: <code>400</code>) do reduction on the full matrix if its size is at most this cutoff. Otherwise do it on a submatrix</li><li><code>reduce_kernelvectors_stepsize</code>: (default: <code>200</code>) the number of extra columns to take into account in each iteration of the reduction step</li></ul></li><li>Transforming the problem and the solution<ul><li><code>unimodular_transform</code>: (default: <code>true</code>) use a unimodular transform obtained in the reduction step</li><li><code>normalize_transformation</code>: (default: <code>true</code>) multiply by a diagonal matrix to get an integer transformation for the problem (for problems over QQ)</li></ul></li><li>Finding an approximate solution in the field<ul><li><code>regularization</code>: (default: <code>1e-20</code>) use this regularization for solving the extended system</li><li><code>approximation_decimals</code>: (default: <code>40</code>) Approximate the numerical solution using this many digits, entrywise</li></ul></li><li>Rounding the solution to the affine space of constraints<ul><li><code>redundancyfactor</code>: (default: <code>10</code>) take at least this times the number of constraints columns as potential pivots</li><li><code>pseudo</code>: (default: <code>true</code>) use the psuedo inverse for rounding (this may give solutions with larger bitsize than needed)</li><li><code>pseudo_columnfactor</code>: (default: <code>1.05</code>) For a system of r rows, use r * pseudo_columnfactor number of columns for the pseudo inverse</li><li><code>extracolumns_linindep</code>: (default: <code>false</code>) if true, take the extra columns linearly independent of each other (otherwise, random columns)</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.SampledMPolyRing-api" href="#ClusteredLowRankSolver.SampledMPolyRing-api"><code>ClusteredLowRankSolver.SampledMPolyRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampledMPolyRing(base_ring, samples)</code></pre><p>A sampled polynomial ring with evaluations in <code>base_ring</code>, only defined on the <code>samples</code>. The samples should be sorted. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.SampledMPolyRingElem-api" href="#ClusteredLowRankSolver.SampledMPolyRingElem-api"><code>ClusteredLowRankSolver.SampledMPolyRingElem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SampledMPolyRinElem(parent::SampledMPolyRing, evaluations::Vector)</code></pre><p>A sampled polynomial corresponding to the given parent, which evaluates to <code>evaluations</code> on the samples of the parent ring.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.SolverFailure-api" href="#ClusteredLowRankSolver.SolverFailure-api"><code>ClusteredLowRankSolver.SolverFailure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverFailure(msg)</code></pre><p>An error in the solver, with a message.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.addconstraint!-Tuple{Problem, Constraint}-api" href="#ClusteredLowRankSolver.addconstraint!-Tuple{Problem, Constraint}-api"><code>ClusteredLowRankSolver.addconstraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addconstraint!(problem, constraint)</code></pre><p>Add <code>constraint</code> to the constraints of <code>problem</code>. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.approximatefekete-Tuple{Any, Any}-api" href="#ClusteredLowRankSolver.approximatefekete-Tuple{Any, Any}-api"><code>ClusteredLowRankSolver.approximatefekete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximatefekete(basis, samples; base_ring=BigFloat) -&gt; basis, samples</code></pre><p>Compute approximate fekete points based on samples and a corresponding orthogonal basis. The basis consists of sampled polynomials, sampled at <code>samples</code>.</p><p>This preserves a degree ordering of <code>basis</code> if present.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.approximatefeketeexact-Tuple{Any, Any, Any}-api" href="#ClusteredLowRankSolver.approximatefeketeexact-Tuple{Any, Any, Any}-api"><code>ClusteredLowRankSolver.approximatefeketeexact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">approximatefeketeexact(R, basis, samples)</code></pre><p>Apply approximate fekete but return an exact basis transformation.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.as_dual_solution-Union{Tuple{T}, Tuple{DualSolution, Vector{T}}} where T-api" href="#ClusteredLowRankSolver.as_dual_solution-Union{Tuple{T}, Tuple{DualSolution, Vector{T}}} where T-api"><code>ClusteredLowRankSolver.as_dual_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">as_dual_solution(sol, x)</code></pre><p>Undo the vectorization of x.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basic_embedding-Tuple{Any}-api" href="#ClusteredLowRankSolver.basic_embedding-Tuple{Any}-api"><code>ClusteredLowRankSolver.basic_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basic_embedding(exactvalue)</code></pre><p>Convert the exact (rational or integer) numbers to floating point approximations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basis_chebyshev-Tuple{Int64, Any}-api" href="#ClusteredLowRankSolver.basis_chebyshev-Tuple{Int64, Any}-api"><code>ClusteredLowRankSolver.basis_chebyshev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_chebyshev(d::Int,x)</code></pre><p>Generate a basis of <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev polynomials</a> up to degree d (inclusive). </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basis_gegenbauer-Tuple{Any, Any, Any}-api" href="#ClusteredLowRankSolver.basis_gegenbauer-Tuple{Any, Any, Any}-api"><code>ClusteredLowRankSolver.basis_gegenbauer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_gegenbauer(d, n, x)</code></pre><p>Basis for the Gegenbauer polynomials in dimension n up to degree d.  This is the Gegenbauer polynomial with parameter lambda = n/2-1,  or the Jacobi polynomial with alpha = beta = (n-3)/2.  Normalized to evaluate to 1 at 1.  Taken from arxiv/2001.00256, ancillary files, SemidefiniteProgramming.jl.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basis_jacobi-api" href="#ClusteredLowRankSolver.basis_jacobi-api"><code>ClusteredLowRankSolver.basis_jacobi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis_jacobi(d::Integer, alpha, beta, x, normalized = true)</code></pre><p>Generate the <a href="https://en.wikipedia.org/wiki/Jacobi_polynomials">Jacobi polynomials</a> with parameters alpha and beta up to degree d (inclusive). </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basis_laguerre-Tuple{Integer, Any, Any}-api" href="#ClusteredLowRankSolver.basis_laguerre-Tuple{Integer, Any, Any}-api"><code>ClusteredLowRankSolver.basis_laguerre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_laguerre(d::Integer, alpha, x)</code></pre><p>Generate the <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">Laguerre polynomials</a> with parameter alpha up to degree d (inclusive). </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.basis_monomial-Tuple{Int64, Vararg{Any}}-api" href="#ClusteredLowRankSolver.basis_monomial-Tuple{Int64, Vararg{Any}}-api"><code>ClusteredLowRankSolver.basis_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_monomial(d::Int, x...)</code></pre><p>Generate the monomial basis in variables x... up to degree d (inclusive).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.blocksizes-Tuple{Problem}-api" href="#ClusteredLowRankSolver.blocksizes-Tuple{Problem}-api"><code>ClusteredLowRankSolver.blocksizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocksizes(problem)</code></pre><p>Return the sizes of the matrix variables as a dictionary with the same keys</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.check_problem-Tuple{Problem}-api" href="#ClusteredLowRankSolver.check_problem-Tuple{Problem}-api"><code>ClusteredLowRankSolver.check_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_problem(problem::LowRankPolProblem)</code></pre><p>Check for obvious mistakes in the constraints and objective</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.check_sdp!-Tuple{ClusteredLowRankSDP}-api" href="#ClusteredLowRankSolver.check_sdp!-Tuple{ClusteredLowRankSDP}-api"><code>ClusteredLowRankSolver.check_sdp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_sdp!(sdp::ClusteredLowRankSDP)</code></pre><p>Check whether the constraint matrices are symmetric, and remove empty constraint matrices.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.constraints-Tuple{Problem}-api" href="#ClusteredLowRankSolver.constraints-Tuple{Problem}-api"><code>ClusteredLowRankSolver.constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraints(problem::Problem)</code></pre><p>Return the constraints of <code>problem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.convert_to_prec-api" href="#ClusteredLowRankSolver.convert_to_prec-api"><code>ClusteredLowRankSolver.convert_to_prec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert_to_prec(sdp, prec=precision(BigFloat))</code></pre><p>Convert the semidefinite program to a semidefinite program with prec bits of precision, without error bounds.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.exact_solution-Tuple{Problem, PrimalSolution, DualSolution}-api" href="#ClusteredLowRankSolver.exact_solution-Tuple{Problem, PrimalSolution, DualSolution}-api"><code>ClusteredLowRankSolver.exact_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exact_solution(problem::Problem, primalsol::PrimalSolution, dualsol::DualSolution; transformed=false, FF = QQ, g=1, settings::RoundingSettings=RoundingSettings(), monomial_bases=nothing)</code></pre><p>Compute and return an exact solution to the problem, given a primal solution, dual solution and a field <code>FF</code> with approximate generator <code>g</code>. Return <code>(success, exactdualsol)</code> if <code>transformed=false</code>, and <code>(success, pd_transformed_exactsolution, transformations)</code> if <code>transformed=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.find_field-Union{Tuple{T}, Tuple{PrimalSolution{T}, DualSolution{T}}, Tuple{PrimalSolution{T}, DualSolution{T}, Any}} where T-api" href="#ClusteredLowRankSolver.find_field-Union{Tuple{T}, Tuple{PrimalSolution{T}, DualSolution{T}}, Tuple{PrimalSolution{T}, DualSolution{T}, Any}} where T-api"><code>ClusteredLowRankSolver.find_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_field(primalsol, dualsol, max_degree=4; valbound=1e-15, errbound=1e-15, bits=100, max_coeff=1000)</code></pre><p>Heuristically find a field over which the kernel can probably be defined. </p><p>Only consider values at least <code>valbound</code> in absolute value. Find minimal polynomials  such that the chosen entries are approximately generators with an error bound of <code>errbound</code>. Use <code>bits</code> number of bits and reject minimal polynomials with a maximum coefficient of more than <code>max_coeff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freecoeff-Tuple{Union{Constraint, Objective}, Any}-api" href="#ClusteredLowRankSolver.freecoeff-Tuple{Union{Constraint, Objective}, Any}-api"><code>ClusteredLowRankSolver.freecoeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freecoeff(x::Union{Constraint, Objective}, name)</code></pre><p>Return the coefficient of the free variable corresponding to <code>name</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freecoeffs-Tuple{Union{Constraint, Objective}}-api" href="#ClusteredLowRankSolver.freecoeffs-Tuple{Union{Constraint, Objective}}-api"><code>ClusteredLowRankSolver.freecoeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freecoeffs(x::Union{Constraint, Objective})</code></pre><p>Return the dictionary of coefficients for the free variables</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freevar-Tuple{DualSolution, Any}-api" href="#ClusteredLowRankSolver.freevar-Tuple{DualSolution, Any}-api"><code>ClusteredLowRankSolver.freevar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freevar(sol, name)</code></pre><p>Return the free variable corresponding to name</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.freevars-Tuple{DualSolution}-api" href="#ClusteredLowRankSolver.freevars-Tuple{DualSolution}-api"><code>ClusteredLowRankSolver.freevars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freevars(sol)</code></pre><p>Return the dictionary of the free variables</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.generic_embedding-Tuple{Union{AbstractAlgebra.MPolyRingElem, AbstractAlgebra.PolyRingElem}, Any}-api" href="#ClusteredLowRankSolver.generic_embedding-Tuple{Union{AbstractAlgebra.MPolyRingElem, AbstractAlgebra.PolyRingElem}, Any}-api"><code>ClusteredLowRankSolver.generic_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generic_embedding(exactvalue, g; base_ring=BigFloat)</code></pre><p>Convert the exact numbers from a number field to floating point approximations,  using a floating point approximation of a generator g of the field.</p><p>Convert rationals and integers to the same numbers in base_ring.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.linearsystem-Tuple{Problem}-api" href="#ClusteredLowRankSolver.linearsystem-Tuple{Problem}-api"><code>ClusteredLowRankSolver.linearsystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearsystem(problem::Problem, FF=QQ)</code></pre><p>Let x be the vcat of the vectorizations of the matrix variables. This function returns the matrix A and vector b such that the constraints are given by the system Ax = b (over the field FF).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.linearsystem_coefficientmatching-Tuple{Problem, Any}-api" href="#ClusteredLowRankSolver.linearsystem_coefficientmatching-Tuple{Problem, Any}-api"><code>ClusteredLowRankSolver.linearsystem_coefficientmatching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearsystem_coefficientmatching(problem::Problem, monomial_basis::Vector{Vector{MPolyRingElem}}; FF=QQ)</code></pre><p>Let x be the vcat of the vectorizations of the matrix variables. This function returns the matrix A and vector b such that the constraints obtained  from coefficient matching are given by the system Ax = b over the field FF, with  one constraint per monomial in monomial_basis. The problem should not contain  SampledMPolyRingElem&#39;s for this to work.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixcoeff-Tuple{Union{Constraint, Objective}, Any}-api" href="#ClusteredLowRankSolver.matrixcoeff-Tuple{Union{Constraint, Objective}, Any}-api"><code>ClusteredLowRankSolver.matrixcoeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixcoeff(x::Union{Constraint, Objective}, name)</code></pre><p>Return the matrix coefficient corresponding to <code>name</code></p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixcoeffs-Tuple{Union{Constraint, Objective}}-api" href="#ClusteredLowRankSolver.matrixcoeffs-Tuple{Union{Constraint, Objective}}-api"><code>ClusteredLowRankSolver.matrixcoeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixcoeffs(x::Union{Constraint, Objective})</code></pre><p>Return the dictionary of matrix coefficients</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixvar-Tuple{DualSolution, Any}-api" href="#ClusteredLowRankSolver.matrixvar-Tuple{DualSolution, Any}-api"><code>ClusteredLowRankSolver.matrixvar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixvar(sol, name)</code></pre><p>Return the matrix variable corresponding to name</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.matrixvars-Tuple{DualSolution}-api" href="#ClusteredLowRankSolver.matrixvars-Tuple{DualSolution}-api"><code>ClusteredLowRankSolver.matrixvars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrixvars(sol)</code></pre><p>Return the dictionary of matrix variables</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.model_psd_variables_as_free_variables!-Tuple{Problem, Any}-api" href="#ClusteredLowRankSolver.model_psd_variables_as_free_variables!-Tuple{Problem, Any}-api"><code>ClusteredLowRankSolver.model_psd_variables_as_free_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_psd_variables_as_free_variables!(problem::Problem, as_free)</code></pre><p>Model the positive semidefinite variables with names in <code>as_free</code> using free variables,  and add extra constraints to set them equal to auxilliary positive semidefinite variables.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.objective-Tuple{Union{Maximize, Minimize, Problem}}-api" href="#ClusteredLowRankSolver.objective-Tuple{Union{Maximize, Minimize, Problem}}-api"><code>ClusteredLowRankSolver.objective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective(x::Union{Maximize, Minimize, Problem})</code></pre><p>Return the objective.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.objvalue-Tuple{Problem, DualSolution}-api" href="#ClusteredLowRankSolver.objvalue-Tuple{Problem, DualSolution}-api"><code>ClusteredLowRankSolver.objvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objvalue(problem::Problem, sol::DualSolution)</code></pre><p>Return the objective value of the dual solution with respect to the given objective or problem.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.objvalue-Union{Tuple{T}, Tuple{Objective, DualSolution{T}}} where T&lt;:Number-api" href="#ClusteredLowRankSolver.objvalue-Union{Tuple{T}, Tuple{Objective, DualSolution{T}}} where T&lt;:Number-api"><code>ClusteredLowRankSolver.objvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objvalue(objective::Objective, sol::DualSolution)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.optimal-Tuple{ClusteredLowRankSolver.Status}-api" href="#ClusteredLowRankSolver.optimal-Tuple{ClusteredLowRankSolver.Status}-api"><code>ClusteredLowRankSolver.optimal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimal(x::Status)</code></pre><p>Return whether the solutions corresponding to this status are optimal.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.partial_linearsystem-Tuple{Problem, DualSolution, Vector{Int64}}-api" href="#ClusteredLowRankSolver.partial_linearsystem-Tuple{Problem, DualSolution, Vector{Int64}}-api"><code>ClusteredLowRankSolver.partial_linearsystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial_linearsystem(problem::Problem, sol::DualSolution, columns::Union{DualSolution, Vector{Int}})</code></pre><p>Let x be the vcat of the vectorizations of the matrix variables. Let I be the index set of the columns. This function returns the matrix A<em>I and vector b-Ax such that the constraints for  the error vector e using variables indexed by I are given by the system A</em>Ie = b-Ax.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sample_points_chebyshev-api" href="#ClusteredLowRankSolver.sample_points_chebyshev-api"><code>ClusteredLowRankSolver.sample_points_chebyshev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_points_chebyshev(d, a = -1, b = 1; T=BigFloat) -&gt; Vector{T}</code></pre><p>Generate the d+1 <a href="https://en.wikipedia.org/wiki/Chebyshev_nodes">Chebyshev points</a> in [a,b].</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sample_points_chebyshev_mod-api" href="#ClusteredLowRankSolver.sample_points_chebyshev_mod-api"><code>ClusteredLowRankSolver.sample_points_chebyshev_mod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_points_chebyshev_mod(d, a = -1, b = 1; T=BigFloat) -&gt; Vector{T}</code></pre><p>Generate the d+1 modified chebyshev points in [a,b], the chebyshev points divided by cos(pi/(2(d+1))).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sample_points_padua-Tuple{Any}-api" href="#ClusteredLowRankSolver.sample_points_padua-Tuple{Any}-api"><code>ClusteredLowRankSolver.sample_points_padua</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_points_padua(d; T=BigFloat) -&gt; Vector{Vector{T}}</code></pre><p>Generate the <a href="https://en.wikipedia.org/wiki/Padua_points">Padua points</a> for degree d.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sample_points_rescaled_laguerre-Tuple{Any}-api" href="#ClusteredLowRankSolver.sample_points_rescaled_laguerre-Tuple{Any}-api"><code>ClusteredLowRankSolver.sample_points_rescaled_laguerre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_points_rescaled_laguerre(d; T=BigFloat) -&gt; Vector{T}</code></pre><p>Generate &#39;rescaled laguerre&#39; points, as in SDPB.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sample_points_simplex-Tuple{Any, Any}-api" href="#ClusteredLowRankSolver.sample_points_simplex-Tuple{Any, Any}-api"><code>ClusteredLowRankSolver.sample_points_simplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_points_simplex(n, d; T=BigFloat) -&gt; Vector{Vector{T}}</code></pre><p>Generate the rational sample points in the unit simplex with denominator d.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sampled_polynomial_ring-Tuple{Any, Any}-api" href="#ClusteredLowRankSolver.sampled_polynomial_ring-Tuple{Any, Any}-api"><code>ClusteredLowRankSolver.sampled_polynomial_ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sampled_polynomial_ring(base_ring, samples)</code></pre><p>Create a <code>SampledMPolyRing</code> with values in <code>base_ring</code> defined on <code>samples</code>. The samples should be sorted.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.sdpa_sparse_to_problem-api" href="#ClusteredLowRankSolver.sdpa_sparse_to_problem-api"><code>ClusteredLowRankSolver.sdpa_sparse_to_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sdpa_sparse_to_problem(filename,obj_shift = 0; T=Float64)</code></pre><p>Define the <code>Problem</code> from the file <code>filename</code> assuming it is in SDPA sparse format, using the number type <code>T</code>. Optionally add an objective shift. </p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.slacks-Tuple{Problem, DualSolution}-api" href="#ClusteredLowRankSolver.slacks-Tuple{Problem, DualSolution}-api"><code>ClusteredLowRankSolver.slacks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slacks(problem, dualsol)</code></pre><p>Compute the difference between the left hand side and the right hand side of all constraints</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.solvesdp-Tuple{Problem}-api" href="#ClusteredLowRankSolver.solvesdp-Tuple{Problem}-api"><code>ClusteredLowRankSolver.solvesdp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">	solvesdp(problem::Problem; kwargs...)</code></pre><pre><code class="nohighlight hljs">    solvesdp(sdp::ClusteredLowRankSDP; kwargs...)</code></pre><p>Solve the semidefinite program generated from <code>problem</code> or <code>sdp</code>. </p><p>Keyword arguments:</p><ul><li><code>prec</code> (default: <code>precision(BigFloat)</code>): the precision used</li><li><code>gamma</code> (default: <code>0.9</code>): the step length reduction; a maximum step length of α reduces to a step length of <code>max(gamma*α,1)</code></li><li><code>beta_(in)feasible</code> (default: <code>0.1</code> (<code>0.3</code>)): the amount mu is tried to be reduced by in each iteration, for (in)feasible solutions</li><li><code>omega_p/d</code> (default: <code>10^10</code>): the starting matrix variable for the primal/dual is <code>omega_p/d*I</code></li><li><code>maxiterations</code> (default: <code>500</code>): the maximum number of iterations</li><li><code>duality_gap_threshold</code> (default: <code>10^-15</code>): how near to optimal the solution needs to be</li><li><code>primal/dual_error_threshold</code> (default:<code>10^-30</code>): how feasible the primal/dual solution needs to be</li><li><code>max_complementary_gap</code> (default: <code>10^100</code>): the maximum of <code>dot(X,Y)/nrows(X)</code> allowed</li><li><code>need_primal_feasible/need_dual_feasible</code> (default: <code>false</code>): terminate when the solution is primal/dual feasible</li><li><code>verbose</code> (default: <code>true</code>): print information after every iteration if true</li><li><code>step_length_threshold</code> (default: <code>10^-7</code>): the minimum step length allowed</li><li><code>primalsol</code> (default: <code>nothing</code>): start from the solution <code>(primalsol, dualsol)</code> if both <code>primalsol</code> and <code>dualsol</code> are given</li><li><code>dualsol</code> (default: <code>nothing</code>): start from the solution <code>(primalsol, dualsol)</code> if both <code>primalsol</code> and <code>dualsol</code> are given</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.to_field-Tuple{Any, Nemo.AbsSimpleNumField, Any}-api" href="#ClusteredLowRankSolver.to_field-Tuple{Any, Nemo.AbsSimpleNumField, Any}-api"><code>ClusteredLowRankSolver.to_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_field(v, N, g; bits=100, errbound=1e-15)</code></pre><p>Find an approximation of v in the number field N, using the approximate generator g of N.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.vectorize-Union{Tuple{DualSolution{T}}, Tuple{T}} where T-api" href="#ClusteredLowRankSolver.vectorize-Union{Tuple{DualSolution{T}}, Tuple{T}} where T-api"><code>ClusteredLowRankSolver.vectorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vectorize(sol)</code></pre><p>Vectorize the solution by taking the upper triangular part of the matrices.  The variables are first sorted by size and then by hash.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/nanleij/ClusteredLowRankSolver.jl.git">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/rounding/">« Rounding the Delsarte LP bound</a><a class="docs-footer-nextpage" href="../references/">References and citing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 27 March 2024 09:20">Wednesday 27 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
