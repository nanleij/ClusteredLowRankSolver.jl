<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rounding · ClusteredLowRankSolver.jl Documentation</title><meta name="title" content="Rounding · ClusteredLowRankSolver.jl Documentation"/><meta property="og:title" content="Rounding · ClusteredLowRankSolver.jl Documentation"/><meta property="twitter:title" content="Rounding · ClusteredLowRankSolver.jl Documentation"/><meta name="description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="og:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><meta property="twitter:description" content="Documentation for ClusteredLowRankSolver.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClusteredLowRankSolver.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../advancedmodeling/">Advanced modeling</a></li><li><a class="tocitem" href="../solving/">Solving</a></li><li class="is-active"><a class="tocitem" href>Rounding</a><ul class="internal"><li><a class="tocitem" href="#A-short-introduction-to-the-rounding-procedure"><span>A short introduction to the rounding procedure</span></a></li><li><a class="tocitem" href="#Settings-for-the-rounding-procedure"><span>Settings for the rounding procedure</span></a></li><li><a class="tocitem" href="#Using-coefficient-matching"><span>Using coefficient matching</span></a></li><li><a class="tocitem" href="#Finding-the-appropriate-number-field-for-the-rounding-procedure"><span>Finding the appropriate number field for the rounding procedure</span></a></li><li><a class="tocitem" href="#Getting-an-exact-feasible-solution-close-to-the-optimum"><span>Getting an exact feasible solution close to the optimum</span></a></li></ul></li><li><a class="tocitem" href="../sdpa/">SDPA-sparse format</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/delsarte/">Delsarte LP bound</a></li><li><a class="tocitem" href="../examples/sphere_packing/">Sphere packing</a></li><li><a class="tocitem" href="../examples/poly_opt/">Symmetric polynomial optimization</a></li><li><a class="tocitem" href="../examples/clustering/">Clustering</a></li><li><a class="tocitem" href="../examples/rounding/">Rounding the Delsarte LP bound</a></li></ul></li><li><a class="tocitem" href="../api/">API reference</a></li><li><a class="tocitem" href="../references/">References and citing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Rounding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rounding</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/nanleij/ClusteredLowRankSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/main/docs/src/rounding.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="secrounding"><a class="docs-heading-anchor" href="#secrounding">Rounding numerical solutions to exact optimal solutions</a><a id="secrounding-1"></a><a class="docs-heading-anchor-permalink" href="#secrounding" title="Permalink"></a></h1><p>In certain situations there are reasons to believe that there is a &#39;nice&#39; optimal solution. That is, the kernel of every optimal solution can be defined over a number field of low algebraic degree and low bit size. In that case, we can use the rounding procedure from [<a href="../references/#CLL24">1</a>] to obtain such a solution from a precise enough solution returned by a semidefinite programming solver. This is implemented in the function <a href="#ClusteredLowRankSolver.exact_solution"><code>exact_solution</code></a>. </p><p>See also the following examples:</p><ul><li><a href="../#rounding_univariate">A very basic example of minimizing a univariate polynomial</a></li><li><a href="../tutorial/#Tutorial">A more involved example of minimizing a multivariate polynomial</a></li><li><a href="../examples/rounding/#exrounding">Rounding the Delsarte LP bound</a> </li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.exact_solution" href="#ClusteredLowRankSolver.exact_solution"><code>ClusteredLowRankSolver.exact_solution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exact_solution(problem::Problem, primalsol::PrimalSolution, dualsol::DualSolution; transformed=false, FF = QQ, g=1, settings::RoundingSettings=RoundingSettings(), monomial_bases=nothing)</code></pre><p>Compute and return an exact solution to the problem, given a primal solution, dual solution and a field <code>FF</code> with approximate generator <code>g</code>. Return <code>(success, exactdualsol)</code> if <code>transformed=false</code>, and <code>(success, pd_transformed_exactsolution, transformations)</code> if <code>transformed=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/29635218deb641cd876cb6bee886b1591ab25a1e/src/rounding.jl#L1336-L1341">source</a></section></article><h2 id="A-short-introduction-to-the-rounding-procedure"><a class="docs-heading-anchor" href="#A-short-introduction-to-the-rounding-procedure">A short introduction to the rounding procedure</a><a id="A-short-introduction-to-the-rounding-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#A-short-introduction-to-the-rounding-procedure" title="Permalink"></a></h2><p>The rounding procedure consists of three steps. First a nice basis for the kernel of the provided solution is found; this defines the optimal face. In the second step, this basis is used as part of a basis transformation, to obtain a smaller semidefinite program where the affine hull of the constraints has a one-to-one correspondence with the original optimal face. The provided solution is also transformed, to obtain a strictly feasible solution of the new semidefinite program. In the last step, we take an approximation of the numerical, transformed solution over the rationals (or a provided number field), and find an exact solution close to it. See [<a href="../references/#CLL24">1</a>] for a more detailed description. </p><h2 id="Settings-for-the-rounding-procedure"><a class="docs-heading-anchor" href="#Settings-for-the-rounding-procedure">Settings for the rounding procedure</a><a id="Settings-for-the-rounding-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Settings-for-the-rounding-procedure" title="Permalink"></a></h2><p>For ease of use, all settings which can be used to tweak the rounding procedure are collected in the <a href="#ClusteredLowRankSolver.RoundingSettings"><code>RoundingSettings</code></a> structure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.RoundingSettings" href="#ClusteredLowRankSolver.RoundingSettings"><code>ClusteredLowRankSolver.RoundingSettings</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RoundingSettings(settings...)</code></pre><p>Settings for the rounding procedure:</p><ol><li>Finding the kernel<ul><li><code>kernel_errbound</code>: (default: <code>1e-10</code>) the allowed error for the kernel vectors. That is, the maximum entry of Xv is in absolute value at most this</li><li><code>kernel_round_errbound</code>: (default: <code>1e-15</code>) the maximum allowed error when rounding the reduced row-echelon form entrywise</li><li><code>kernel_use_primal</code>: (default: <code>true</code>) use the primal solution to find the kernel vectors  (otherwise, use an SVD of the dual solution)</li><li><code>kernel_lll</code>: (default: <code>false</code>) if true, use the LLL algorithm to find the nullspace of the kernel. Otherwise, use the reduced row-echelon form to find kernel vectors.</li><li><code>kernel_bits</code>: (default: <code>1000</code>) the maximum number of bits to be used in the LLL algorithm (for finding relations or finding the entries of the RREF)</li></ul></li><li>Reducing the kernel vectors<ul><li><code>reduce_kernelvectors</code>: (default: <code>true</code>) apply the reduction step or not</li><li><code>reduce_kernelvectors_cutoff</code>: (default: <code>400</code>) do reduction on the full matrix if its size is at most this cutoff. Otherwise do it on a submatrix</li><li><code>reduce_kernelvectors_stepsize</code>: (default: <code>200</code>) the number of extra columns to take into account in each iteration of the reduction step</li></ul></li><li>Transforming the problem and the solution<ul><li><code>unimodular_transform</code>: (default: <code>true</code>) use a unimodular transform obtained in the reduction step</li><li><code>normalize_transformation</code>: (default: <code>true</code>) multiply by a diagonal matrix to get an integer transformation for the problem (for problems over QQ)</li></ul></li><li>Finding an approximate solution in the field<ul><li><code>regularization</code>: (default: <code>1e-20</code>) use this regularization for solving the extended system</li><li><code>approximation_decimals</code>: (default: <code>40</code>) Approximate the numerical solution using this many digits, entrywise</li></ul></li><li>Rounding the solution to the affine space of constraints<ul><li><code>redundancyfactor</code>: (default: <code>10</code>) take at least this times the number of constraints columns as potential pivots</li><li><code>pseudo</code>: (default: <code>true</code>) use the psuedo inverse for rounding (this may give solutions with larger bitsize than needed)</li><li><code>pseudo_columnfactor</code>: (default: <code>1.05</code>) For a system of r rows, use r * pseudo_columnfactor number of columns for the pseudo inverse</li><li><code>extracolumns_linindep</code>: (default: <code>false</code>) if true, take the extra columns linearly independent of each other (otherwise, random columns)</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/29635218deb641cd876cb6bee886b1591ab25a1e/src/rounding.jl#L1-L27">source</a></section></article><h3 id="roundingsettings"><a class="docs-heading-anchor" href="#roundingsettings">Finding the right settings</a><a id="roundingsettings-1"></a><a class="docs-heading-anchor-permalink" href="#roundingsettings" title="Permalink"></a></h3><p>Depending on the problem, the default parameters will suffice. In the following cases small changes are needed:</p><ol><li>The kernel vectors are not found correctly, or have significantly higher maximum number after reduction than the maximum numerator and denominator.<ul><li>Try to solve to a smaller duality gap, and/or decrease the setting <code>kernel_round_errbound</code>.</li><li>Try the settings <code>kernel_use_primal=false</code>.</li></ul></li><li>The final solution does not satisfy the constraints. (Or not enough pivots were found) <ul><li>increase <code>redundancyfactor</code>, or set it to <code>-1</code> to take all variables into account.</li><li>This might also be an indication that the kernel vectors are not found correctly (see item 1).</li></ul></li><li>The final solution is not positive semidefinite.<ul><li>Increase the setting <code>approximation_decimals</code>. Make sure that the provided solution has at least that many digits correct (the duality gap should be lower than <code>10^(-approximation_digits)</code>)</li><li>Increase the setting <code>pseudo_columnfactor</code>. The higher this setting, the closer the exact solution will be to the provided solution. However, this also increases the bit size of the exact solution.</li><li>In some cases this is also an indication that the kernel vectors are not found correctly (see item 1), especially when the reported negative eigenvalues are close to zero.</li></ul></li></ol><h2 id="Using-coefficient-matching"><a class="docs-heading-anchor" href="#Using-coefficient-matching">Using coefficient matching</a><a id="Using-coefficient-matching-1"></a><a class="docs-heading-anchor-permalink" href="#Using-coefficient-matching" title="Permalink"></a></h2><p>Although the semidefinite program used in the solver is defined using sampling, it is possible to use a semidefinite program defined using coefficient matching in a monomial basis for the rounding procedure. This is not yet fully automated; the user needs to provide the monomial basis for each polynomial constraint to the rounding procedure in order to use this. Using coefficient matching instead of sampling in the rounding heuristic generally decreases the size of the exact solutions. See below for an example using the slightly modified code for the Delsarte LP bound in the <a href="../examples/rounding/#exrounding">example</a> for rounding. Here we have one univariate constraint with polynomials up to degree <span>$2d$</span>.</p><pre><code class="language-julia hljs">d = 3
problem, primalsol, dualsol = delsarte(8, 1//2, d; duality_gap_threshold=1e-30)
R, (x,) = polynomial_ring(QQ, 1)
mon_basis = [x^k for k=0:2d]
success, exactdualsol = exact_solution(problem, primalsol, dualsol, monbases = [mon_basis])</code></pre><h2 id="Finding-the-appropriate-number-field-for-the-rounding-procedure"><a class="docs-heading-anchor" href="#Finding-the-appropriate-number-field-for-the-rounding-procedure">Finding the appropriate number field for the rounding procedure</a><a id="Finding-the-appropriate-number-field-for-the-rounding-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-appropriate-number-field-for-the-rounding-procedure" title="Permalink"></a></h2><p>It is in general not directly clear over which  number field the optimal face can be defined. The function <a href="#ClusteredLowRankSolver.find_field"><code>find_field</code></a> can help to find such a field. See Section 2.5 of [<a href="../references/#CLL24">1</a>] for an explanation of the procedure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClusteredLowRankSolver.find_field" href="#ClusteredLowRankSolver.find_field"><code>ClusteredLowRankSolver.find_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_field(primalsol, dualsol, max_degree=4; valbound=1e-15, errbound=1e-15, bits=100, max_coeff=1000)</code></pre><p>Heuristically find a field over which the kernel can probably be defined. </p><p>Only consider values at least <code>valbound</code> in absolute value. Find minimal polynomials  such that the chosen entries are approximately generators with an error bound of <code>errbound</code>. Use <code>bits</code> number of bits and reject minimal polynomials with a maximum coefficient of more than <code>max_coeff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nanleij/ClusteredLowRankSolver.jl/blob/29635218deb641cd876cb6bee886b1591ab25a1e/src/find_field.jl#L86-L94">source</a></section></article><h2 id="Getting-an-exact-feasible-solution-close-to-the-optimum"><a class="docs-heading-anchor" href="#Getting-an-exact-feasible-solution-close-to-the-optimum">Getting an exact feasible solution close to the optimum</a><a id="Getting-an-exact-feasible-solution-close-to-the-optimum-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-an-exact-feasible-solution-close-to-the-optimum" title="Permalink"></a></h2><p>In general, the kernel of the optimal solutions can only be defined using a number field of high algebraic degree, or with large bit size. In this case it is unlikely that the exact kernel can be found, so that the rounding procedure will fail. However, it is possible to get an exact feasible solution with objective value close to the optimum using the rounding procedure. To do this, solve the semidefinite program as a feasibility problem (no objective), with the extra constraint that the (original) objective should be a rational number close to the optimum value. Then the solver will return a strictly feasible solution if it exists (that is, with empty kernel). The function <a href="#ClusteredLowRankSolver.exact_solution"><code>exact_solution</code></a> will now essentially skip the steps of finding the kernel vectors and transforming the problem, since there are no kernel vectors. Therefore, it will find an exact feasible solution close to the provided solution such that the objective of the original problem is equal to the rational number in the extra constraint. See <a href="../examples/rounding/#exrounding">Rounding the Delsarte LP bound</a> for a worked example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solving/">« Solving</a><a class="docs-footer-nextpage" href="../sdpa/">SDPA-sparse format »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 23 April 2024 09:36">Tuesday 23 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
